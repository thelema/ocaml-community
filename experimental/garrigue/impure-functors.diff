Index: parsing/parser.mly
===================================================================
--- parsing/parser.mly	(revision 13278)
+++ parsing/parser.mly	(working copy)
@@ -532,8 +532,12 @@
       { unclosed "struct" 1 "end" 3 }
   | FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_expr
       { mkmod(Pmod_functor(mkrhs $3 3, $5, $8)) }
+  | FUNCTOR LPAREN RPAREN MINUSGREATER module_expr
+      { mkmod(Pmod_functor(mkrhs "*" 3, mkmty (Pmty_signature []), $5)) }
   | module_expr LPAREN module_expr RPAREN
       { mkmod(Pmod_apply($1, $3)) }
+  | module_expr LPAREN RPAREN
+      { mkmod(Pmod_apply($1, mkmod (Pmod_structure []))) }
   | module_expr LPAREN module_expr error
       { unclosed "(" 2 ")" 4 }
   | LPAREN module_expr COLON module_type RPAREN
@@ -610,6 +614,8 @@
       { mkmod(Pmod_constraint($4, $2)) }
   | LPAREN UIDENT COLON module_type RPAREN module_binding
       { mkmod(Pmod_functor(mkrhs $2 2, $4, $6)) }
+  | LPAREN RPAREN module_binding
+      { mkmod(Pmod_functor(mkrhs "*" 1, mkmty(Pmty_signature []), $3)) }
 ;
 module_rec_bindings:
     module_rec_binding                            { [$1] }
@@ -631,6 +637,9 @@
   | FUNCTOR LPAREN UIDENT COLON module_type RPAREN MINUSGREATER module_type
       %prec below_WITH
       { mkmty(Pmty_functor(mkrhs $3 3, $5, $8)) }
+  | FUNCTOR LPAREN RPAREN MINUSGREATER module_type
+      %prec below_WITH
+      { mkmty(Pmty_functor(mkrhs "*" 2, mkmty(Pmty_signature []), $5)) }
   | module_type WITH with_constraints
       { mkmty(Pmty_with($1, List.rev $3)) }
   | MODULE TYPE OF module_expr
Index: typing/typemod.ml
===================================================================
--- typing/typemod.ml	(revision 13278)
+++ typing/typemod.ml	(working copy)
@@ -37,6 +37,7 @@
   | Not_a_packed_module of type_expr
   | Incomplete_packed_module of type_expr
   | Scoping_pack of Longident.t * type_expr
+  | Apply_impure
 
 exception Error of Location.t * error
 
@@ -832,8 +833,10 @@
            mod_loc = smod.pmod_loc }
   | Pmod_functor(name, smty, sbody) ->
       let mty = transl_modtype env smty in
-      let (id, newenv) = Env.enter_module name.txt mty.mty_type env in
-      let body = type_module sttn true None newenv sbody in
+      let (id, newenv), funct_body =
+	if name.txt = "*" then (Ident.create "*", env), false else 
+	Env.enter_module name.txt mty.mty_type env, true in
+      let body = type_module sttn funct_body None newenv sbody in
       rm { mod_desc = Tmod_functor(id, name, mty, body);
            mod_type = Mty_functor(id, mty.mty_type, body.mod_type);
            mod_env = env;
@@ -845,6 +848,13 @@
         type_module (sttn && path <> None) funct_body None env sfunct in
       begin match Mtype.scrape env funct.mod_type with
         Mty_functor(param, mty_param, mty_res) as mty_functor ->
+          let impure = Ident.name param = "*" in
+          if impure then begin
+            if sarg.pmod_desc <> Pmod_structure [] then
+              raise (Error (sfunct.pmod_loc, Apply_impure));
+            if funct_body then
+              raise (Error (smod.pmod_loc, Not_allowed_in_functor_body));
+          end;
           let coercion =
             try
               Includemod.modtypes env arg.mod_type mty_param
@@ -856,6 +866,7 @@
                 Subst.modtype (Subst.add_module param path Subst.identity)
                               mty_res
             | None ->
+                if impure then mty_res else
                 try
                   Mtype.nondep_supertype
                     (Env.add_module param arg.mod_type env) param mty_res
@@ -1429,7 +1440,7 @@
         Location.print_filename intf_name
   | Not_allowed_in_functor_body ->
       fprintf ppf
-        "This kind of expression is not allowed within the body of a functor."
+        "This kind of expression is only allowed inside impure functors."
   | With_need_typeconstr ->
       fprintf ppf
         "Only type constructors with identical parameters can be substituted."
@@ -1446,3 +1457,5 @@
         "The type %a in this module cannot be exported.@ " longident lid;
       fprintf ppf
         "Its type contains local dependencies:@ %a" type_expr ty
+  | Apply_impure ->
+      fprintf ppf "This functor is impure. It can only be applied to ()"
Index: typing/typemod.mli
===================================================================
--- typing/typemod.mli	(revision 13278)
+++ typing/typemod.mli	(working copy)
@@ -60,6 +60,7 @@
   | Not_a_packed_module of type_expr
   | Incomplete_packed_module of type_expr
   | Scoping_pack of Longident.t * type_expr
+  | Apply_impure
 
 exception Error of Location.t * error
 
Index: typing/oprint.ml
===================================================================
--- typing/oprint.ml	(revision 13278)
+++ typing/oprint.ml	(working copy)
@@ -343,6 +343,8 @@
 let rec print_out_module_type ppf =
   function
     Omty_abstract -> ()
+  | Omty_functor ("*", _, mty_res) ->
+      fprintf ppf "@[<2>functor@ () ->@ %a@]" print_out_module_type mty_res
   | Omty_functor (name, mty_arg, mty_res) ->
       fprintf ppf "@[<2>functor@ (%s : %a) ->@ %a@]" name
         print_out_module_type mty_arg print_out_module_type mty_res
Index: typing/mtype.ml
===================================================================
--- typing/mtype.ml	(revision 13278)
+++ typing/mtype.ml	(working copy)
@@ -34,7 +34,8 @@
   match scrape env mty with
     Mty_signature sg ->
       Mty_signature(strengthen_sig env sg p)
-  | Mty_functor(param, arg, res) when !Clflags.applicative_functors ->
+  | Mty_functor(param, arg, res)
+    when !Clflags.applicative_functors && Ident.name param <> "*" ->
       Mty_functor(param, arg, strengthen env res (Papply(p, Pident param)))
   | mty ->
       mty
